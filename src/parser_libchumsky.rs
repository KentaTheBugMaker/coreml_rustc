use std::fmt::Display;

use chumsky::extra::Err;
use chumsky::prelude::*;
use chumsky::Parser;

use crate::flat_syntax::Dec;
use crate::flat_syntax::Exp;
use crate::flat_syntax::Prim;

pub type MySpan = SimpleSpan<usize>;
#[derive(Debug, Clone, PartialEq)]
pub enum Token<'src> {
    String(&'src str),
    Add,
    Comma,
    DArrow,
    Div,
    Else,
    Eof,
    Eq,
    Equal,
    False,
    Fn,
    Fun,
    Hash1,
    Hash2,
    Id(&'src str),
    If,
    Int(i64),
    LParen,
    Mul,
    RParen,
    Semicolon,
    Sub,
    Then,
    True,
    Val,
}

impl<'src> Display for Token<'src> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::String(a) => write!(f, "\"{}\"", a),
            Token::Add => write!(f, "add",),
            Token::Comma => write!(f, ",",),
            Token::DArrow => write!(f, "=>",),
            Token::Div => write!(f, "div",),
            Token::Else => write!(f, "else",),
            Token::Eof => write!(f, "eof",),
            Token::Eq => write!(f, "eq",),
            Token::Equal => write!(f, "=",),
            Token::False => write!(f, "false",),
            Token::Fn => write!(f, "fn",),
            Token::Fun => write!(f, "fun",),
            Token::Hash1 => write!(f, "#1",),
            Token::Hash2 => write!(f, "#2",),
            Token::Id(x) => write!(f, "{x:}",),
            Token::If => write!(f, "if",),
            Token::Int(x) => write!(f, "{x:}",),
            Token::LParen => write!(f, "(",),
            Token::Mul => write!(f, "mul",),
            Token::RParen => write!(f, ")",),
            Token::Semicolon => write!(f, ";",),
            Token::Sub => write!(f, "sub",),
            Token::Then => write!(f, "then",),
            Token::True => write!(f, "true",),
            Token::Val => write!(f, "val",),
        }
    }
}

pub fn lexer<'src>(
) -> impl Parser<'src, &'src str, Vec<(Token<'src>, MySpan)>, Err<Rich<'src, char, MySpan>>> {
    use Token::*;
    let int = text::int(10).to_slice().from_str().unwrapped().map(Int);
    let string = just('"')
        .ignore_then(none_of('"').repeated())
        .then_ignore(just('"'))
        .to_slice()
        .map(String);
    let id = regex("[a-zA-Z][a-zA-Z0-9]*")
        .to_slice()
        .map(|id: &str| match id {
            "add" => Add,
            "sub" => Sub,
            "mul" => Mul,
            "div" => Div,
            "fn" => Fn,
            "fun" => Fun,
            "val" => Val,
            "eq" => Eq,
            "if" => If,
            "then" => Then,
            "true" => True,
            "false" => False,
            "else" => Else,
            any => Id(any),
        });
    let hash1 = just("#1").to(Hash1);
    let hash2 = just("#2").to(Hash2);
    let lparen = just("(").to(LParen);
    let rparen = just(")").to(RParen);
    let comma = just(",").to(Comma);
    let equal = just("=").to(Equal);
    let darrow = just("=>").to(DArrow);
    let semicolon = just(";").to(Semicolon);
    let token = choice((
        int, id, string, hash1, hash2, lparen, rparen, comma, darrow, equal, semicolon,
    ));
    token
        .map_with(|tok, e| (tok, e.span()))
        .padded()
        .recover_with(skip_then_retry_until(any().ignored(), end()))
        .repeated()
        .collect()
}
// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
// to understand.
type ParserInput<'tokens, 'src> =
    chumsky::input::SpannedInput<Token<'src>, MySpan, &'tokens [(Token<'src>, MySpan)]>;
pub type Spanned<T> = (T, MySpan);

pub fn decl_parser<'tokens, 'src: 'tokens>() -> impl Parser<
    'tokens,
    ParserInput<'tokens, 'src>,
    Vec<Dec>,
    extra::Err<Rich<'tokens, Token<'src>, MySpan>>,
> + Clone {
    let val_parser = just(Token::Val)
        .ignore_then(select! {
            Token::Id(name)=>name.to_owned()
        })
        .then_ignore(just(Token::Equal))
        .then(expr_parser())
        .map(|(name, exp)| Dec::Val(name, exp));
    let fun_parser = just(Token::Fun)
        .ignore_then(select! {
            Token::Id(name)=>name.to_owned()
        })
        .then(select! {
            Token::Id(name)=>name.to_owned()
        })
        .then_ignore(just(Token::Equal))
        .then(expr_parser())
        .map(|((function_name, val_name), exp)| {
            let span = exp.1.clone();
            Dec::Val(
                function_name.clone(),
                (Exp::ExpFix(function_name, val_name, Box::new(exp)), span),
            )
        });
    val_parser.or(fun_parser).repeated().collect()
}

pub fn expr_parser<'tokens, 'src: 'tokens>() -> impl Parser<
    'tokens,
    ParserInput<'tokens, 'src>,
    Spanned<Exp>,
    extra::Err<Rich<'tokens, Token<'src>, MySpan>>,
> + Clone {
    recursive(|exp| {
        let at_exp = recursive(|at_exp| {
            let _const = select! {Token::True=>crate::flat_syntax::Exp::True,
                Token::False=>crate::flat_syntax::Exp::False,
                Token::Int(x)=>crate::flat_syntax::Exp::Int(x),
                Token::String(x)=>crate::flat_syntax::Exp::String(x.to_owned()),
                Token::Id(ident) => Exp::ExpId(ident.to_owned()) ,
            }
            .labelled("constant or identifier")
            .map_with(|a, e| (a, e.span()));

            let tuple = just(Token::LParen)
                .ignore_then(exp.clone())
                .then_ignore(just(Token::Comma))
                .then(exp.clone())
                .then_ignore(just(Token::RParen))
                .map_with(|(a, b), e| (Exp::ExpPair(Box::new(a), Box::new(b)), e.span()));

            let nested = just(Token::LParen)
                .ignore_then(exp.clone())
                .then_ignore(just(Token::RParen))
                .map_with(|(exp, _inner_span), e| (exp, e.span()));

            let proj = select! {
                Token::Hash1=>1,
                Token::Hash2=>2,
            }
            .labelled("destruct tuple")
            .then(at_exp.clone())
            .map_with(|(accessor, exp), e| match accessor {
                1 => (Exp::ExpProj1(Box::new(exp)), e.span()),
                2 => (Exp::ExpProj2(Box::new(exp)), e.span()),
                x => unimplemented!("tuple accessor is not implemented for {x:?}"),
            });

            let prim = one_of(&[Token::Add, Token::Sub, Token::Mul, Token::Div, Token::Eq])
                .then_ignore(just(Token::LParen))
                .then(exp.clone())
                .then_ignore(just(Token::Comma))
                .then(exp.clone())
                .then_ignore(just(Token::RParen))
                .map_with(|((operator, exp1), exp2), e| {
                    (
                        Exp::ExpPrim(
                            match operator {
                                Token::Add => Prim::Add,
                                Token::Div => Prim::Div,
                                Token::Sub => Prim::Sub,
                                Token::Mul => Prim::Mul,
                                Token::Eq => Prim::Eq,
                                x => panic!(" {x:?} is not primitive operation"),
                            },
                            Box::new(exp1),
                            Box::new(exp2),
                        ),
                        e.span(),
                    )
                });
            choice((_const, tuple, nested, proj, prim))
        });

        let app_exp = at_exp
            .repeated()
            .at_least(1)
            .collect::<Vec<(Exp, SimpleSpan)>>()
            .map(|applications: Vec<(Exp, SimpleSpan)>| {
                applications.into_iter().reduce(|appexp, atexp| {
                    let span_left = appexp.clone().1;
                    let span_right = atexp.clone().1;
                    (
                        Exp::ExpApp(Box::new(appexp.clone()), Box::new(atexp.clone())),
                        span_left.union(span_right),
                    )
                })
            })
            .unwrapped();
        let if_exp = just(Token::If)
            .ignore_then(exp.clone())
            .then_ignore(just(Token::Then))
            .then(exp.clone())
            .then_ignore(just(Token::Else))
            .then(exp.clone())
            .map_with(|((cond, then), els), e| {
                (
                    Exp::ExpIf(Box::new(cond), Box::new(then), Box::new(els)),
                    e.span(),
                )
            });
        let fn_expression = just(Token::Fn)
            .ignore_then(select! {Token::Id(ident)=>ident.to_owned()})
            .then_ignore(just(Token::DArrow))
            .then(exp.clone())
            .map_with(|(var, exp), e| (Exp::ExpFn(var, Box::new(exp)), e.span()));
        if_exp.or(fn_expression).or(app_exp)
    })
}
