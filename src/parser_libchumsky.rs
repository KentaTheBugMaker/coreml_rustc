use std::fmt::Display;

use crate::syntax_tree::{ApplyExpression, AtomicExpression, Dec, Expression, Prim};
use chumsky::extra::Err;
use chumsky::prelude::*;
use chumsky::Parser;

pub type Span = SimpleSpan<usize>;
#[derive(Debug, Clone, PartialEq)]
pub enum Token<'src> {
    String(&'src str),
    Add,
    Comma,
    DArrow,
    Div,
    Else,
    Eof,
    Eq,
    Equal,
    False,
    Fn,
    Fun,
    Hash1,
    Hash2,
    Id(&'src str),
    If,
    Int(i64),
    LParen,
    Mul,
    RParen,
    Semicolon,
    Sub,
    Then,
    True,
    Val,
}

impl<'src> Display for Token<'src> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::String(a) => write!(f, "\"{}\"", a),
            Token::Add => write!(f, "add",),
            Token::Comma => write!(f, ",",),
            Token::DArrow => write!(f, "=>",),
            Token::Div => write!(f, "div",),
            Token::Else => write!(f, "else",),
            Token::Eof => write!(f, "eof",),
            Token::Eq => write!(f, "eq",),
            Token::Equal => write!(f, "=",),
            Token::False => write!(f, "false",),
            Token::Fn => write!(f, "fn",),
            Token::Fun => write!(f, "fun",),
            Token::Hash1 => write!(f, "#1",),
            Token::Hash2 => write!(f, "#2",),
            Token::Id(x) => write!(f, "{x:}",),
            Token::If => write!(f, "if",),
            Token::Int(x) => write!(f, "{x:}",),
            Token::LParen => write!(f, "(",),
            Token::Mul => write!(f, "mul",),
            Token::RParen => write!(f, ")",),
            Token::Semicolon => write!(f, ";",),
            Token::Sub => write!(f, "sub",),
            Token::Then => write!(f, "then",),
            Token::True => write!(f, "true",),
            Token::Val => write!(f, "val",),
        }
    }
}

pub fn lexer<'src>(
) -> impl Parser<'src, &'src str, Vec<(Token<'src>, Span)>, Err<Rich<'src, char, Span>>> {
    use Token::*;
    let int = text::int(10).to_slice().from_str().unwrapped().map(Int);
    let string = just('"')
        .ignore_then(none_of('"').repeated())
        .then_ignore(just('"'))
        .to_slice()
        .map(String);
    let id = regex("[a-zA-Z][a-zA-Z0-9]*")
        .to_slice()
        .map(|id: &str| match id {
            "add" => Add,
            "sub" => Sub,
            "mul" => Mul,
            "div" => Div,
            "fn" => Fn,
            "fun" => Fun,
            "val" => Val,
            "eq" => Eq,
            "if" => If,
            "then" => Then,
            "true" => True,
            "false" => False,
            "else" => Else,
            any => Id(any),
        });
    let hash1 = just("#1").to(Hash1);
    let hash2 = just("#2").to(Hash2);
    let lparen = just("(").to(LParen);
    let rparen = just(")").to(RParen);
    let comma = just(",").to(Comma);
    let equal = just("=").to(Equal);
    let darrow = just("=>").to(DArrow);
    let semicolon = just(";").to(Semicolon);
    let token = choice((
        int, id, string, hash1, hash2, lparen, rparen, comma, darrow, equal, semicolon,
    ));
    token
        .map_with(|tok, e| (tok, e.span()))
        .padded()
        .recover_with(skip_then_retry_until(any().ignored(), end()))
        .repeated()
        .collect()
}
// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
// to understand.
type ParserInput<'tokens, 'src> =
    chumsky::input::SpannedInput<Token<'src>, Span, &'tokens [(Token<'src>, Span)]>;
pub type Spanned<T> = (T, Span);

pub fn decl_parser<'tokens, 'src: 'tokens>() -> impl Parser<
    'tokens,
    ParserInput<'tokens, 'src>,
    Vec<Dec>,
    extra::Err<Rich<'tokens, Token<'src>, Span>>,
> + Clone {
    let val_parser = just(Token::Val)
        .ignore_then(select! {
            Token::Id(name)=>name.to_owned()
        })
        .then_ignore(just(Token::Equal))
        .then(expr_parser())
        .map(|(name, exp)| Dec::Val {
            name,
            expression: Box::new(exp.0),
        });
    let fun_parser = just(Token::Fun)
        .ignore_then(select! {
            Token::Id(name)=>name.to_owned()
        })
        .then(select! {
            Token::Id(name)=>name.to_owned()
        })
        .then_ignore(just(Token::Equal))
        .then(expr_parser())
        .map(|((function_name, val_name), exp)| Dec::Fun {
            function_name,
            val_name,
            expression: Box::new(exp.0),
        });
    val_parser.or(fun_parser).repeated().collect()
}

pub fn expr_parser<'tokens, 'src: 'tokens>() -> impl Parser<
    'tokens,
    ParserInput<'tokens, 'src>,
    Spanned<Expression>,
    extra::Err<Rich<'tokens, Token<'src>, Span>>,
> + Clone {
    recursive(|exp| {
        let at_exp = recursive(|at_exp| {
            let _const = select! {Token::True=>AtomicExpression::Const(crate::syntax_tree::Const::True),
                Token::False=>AtomicExpression::Const(crate::syntax_tree::Const::False),
                Token::Int(x)=>AtomicExpression::Const(crate::syntax_tree::Const::Int(x)),
                Token::String(x)=>AtomicExpression::Const(crate::syntax_tree::Const::String(x.to_owned())),
            };

            let ident = select! { Token::Id(ident) => ident.to_owned() }
                .labelled("identifier")
                .map(AtomicExpression::Id);

            let tuple = just(Token::LParen)
                .ignore_then(exp.clone())
                .then_ignore(just(Token::Comma))
                .then(exp.clone())
                .then_ignore(just(Token::RParen))
                .map(|((a, _span1), (b, _span2))| AtomicExpression::Pair(Box::new(a), Box::new(b)));

            let nested = just(Token::LParen)
                .ignore_then(exp.clone())
                .then_ignore(just(Token::RParen))
                .map(|(expr, _span)| AtomicExpression::Expression(Box::new(expr)));

            let proj = select! {
                Token::Hash1=>1,
                Token::Hash2=>2,
            }
            .labelled("destruct tuple")
            .then(at_exp.clone())
            .map(|(accessor, exp)| match accessor {
                1 => AtomicExpression::ExtractFirst(Box::new(exp)),
                2 => AtomicExpression::ExtractSecond(Box::new(exp)),
                x => unimplemented!("tuple accessor is not implemented for {x:?}"),
            });

            let prim = one_of(&[Token::Add, Token::Sub, Token::Mul, Token::Div, Token::Eq])
                .then_ignore(just(Token::LParen))
                .then(exp.clone())
                .then_ignore(just(Token::Comma))
                .then(exp.clone())
                .then_ignore(just(Token::RParen))
                .map(|((operator, (exp1, _span1)), (exp2, _span2))| {
                    AtomicExpression::Prim(
                        match operator {
                            Token::Add => Prim::Add,
                            Token::Div => Prim::Div,
                            Token::Sub => Prim::Sub,
                            Token::Mul => Prim::Mul,
                            Token::Eq => Prim::Eq,
                            x => panic!(" {x:?} is not primitive operation"),
                        },
                        Box::new(exp1),
                        Box::new(exp2),
                    )
                });
            choice((_const, ident, tuple, nested, proj, prim))
        });

        let app_exp = at_exp
            .clone()
            .repeated()
            .at_least(1)
            .collect()
            .map(ApplyExpression);

        let if_exp = just(Token::If)
            .ignore_then(exp.clone())
            .then_ignore(just(Token::Then))
            .then(exp.clone())
            .then_ignore(just(Token::Else))
            .then(exp.clone())
            .map_with(|(((cond, _span1), (then, _span2)), (els, _span3)), e| {
                (
                    Expression::If {
                        condition: Box::new(cond),
                        then_section: Box::new(then),
                        else_section: Box::new(els),
                    },
                    e.span(),
                )
            });
        let fn_expression = just(Token::Fn)
            .ignore_then(select! {Token::Id(ident)=>ident.to_owned()})
            .then_ignore(just(Token::DArrow))
            .then(exp.clone())
            .map_with(|(var, (exp, _span)), e| {
                (
                    Expression::Fn {
                        var,
                        expression: Box::new(exp),
                    },
                    e.span(),
                )
            });
        if_exp
            .or(fn_expression)
            .or(app_exp.map_with(|appexp, e| (Expression::AppExp(appexp), e.span())))
    })
}
